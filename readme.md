# Drone Simulation Project

## Overview
This project is an interactive drone simulation that operates in a terminal-based environment using `ncurses`. The simulation consists of:

A controllable drone navigating in a bounded area, Randomly appearing and disappearing obstacles and targets, Repulsion forces following Khatib's model, Multiple modes of operation, including local and remote object generation using FastDDS.

![image info](imgs/screencast.gif)

- **Real-time Drone Control**: Users can move the drone using keyboard input.
- **Speed Adjustment**: Pressing the same movement key repeatedly increases the drone's speed.
- **Map Visualization**: The path of the drone can be presented once it had moved a bit, using the Map key.
- **Multi-process architecture**: A master process forks and runs other processes.
- **Shared memory & IPC**: Uses shared memory structs for inter-process communication and pipes for watchdog monitoring.
- **Logging**: Logs critical simulation events.
- **Watchdog monitoring**: Ensures all processes remain active by receiving heartbeats.
- **Configurable via JSON**: Parameters are dynamically loaded from `config.json`.
- **Memory Leak Checked**: Verification of memory safety using Valgrind.

## Project Structure
![image info](imgs/structure.png)
```
.
├── compile.sh
├── config.json
├── master
├── bins
│   ├── ....out
<!-- │   ├── Blackboard.out
│   ├── Dynamics.out
│   ├── Keyboard.out
│   ├── ObjectPub.out
│   ├── ObjectSub.out
│   ├── Obstacle.out
│   ├── Target.out
│   ├── Watchdog.out
│   ├── Window.out -->
├── logs
│   └── simulation.log
├── src
│   ├── Generated
│   │   ├── ....hpp
│   ├── Obstacles.idl
│   ├── blackboard.c/h
│   ├── dynamics.c
│   ├── keyboard.c
│   ├── logger.c/h
│   ├── master.c
│   ├── objectpublisher.cpp
│   ├── objectsubscriber.cpp
│   ├── obstacle.c
│   ├── target.c
│   ├── watchdog.c
│   └── windownew.c
``` 

## Simulation Dynamics
![image info](imgs/forcefield.png)
The drone operates with two degrees of freedom and follows the equation of motion:

\[
\sum \mathbf{F} = M \frac{d^2 \mathbf{p}}{dt^2} + K \frac{d \mathbf{p}}{dt}
\]

\[ \sum F = M \frac{d^2 p}{dt^2} + K \frac{dp}{dt} \]

Where:
- **p** = drone position
- **F** = sum of forces (control, repulsion, attraction)
- **M** = mass (1.0 Kg)
- **K** = viscous coefficient (1.0 N·s·m)

### Khatib's Model for Obstacle Repulsion
The repulsive force \(F_r\) from an obstacle at distance \(d\) is defined as:
\[ F_r = \eta \left( \frac{1}{d} - \frac{1}{d_0} \right) \frac{1}{d^2} \]
where:
- \( \eta \) is the gain factor
- \( d_0 \) is the influence radius

Noteworthy that the repulsion force is topped at 100. Attractive forces from targets follow a (kind of) similar formulation, both detailed in `src/dynamics.c`. 

## Modes of Operation

Upon running, the user selects the operation mode:
```
WELCOME TO DRONE SIMULATION.
Choose mode of operation ...
(1): Local object generation and simulation
(2): Remote object generation and simulation
(3): Object generation and publish over network
Enter mode:
```
### Mode 1: Local Object Generation
- Obstacles and targets are generated by two processes locally.
- Shared memory is used for inter-process communication.
- The user controls the drone locally.

### Mode 2: Remote Object Generation (FastDDS Receiver)
- Obstacles and targets are received remotely via FastDDS.
- Shared memory is used for inter-process communication.
- The user controls the drone locally.

### Mode 3: Object Generation and Publishing (FastDDS Transmitter)
- Random obstacles and targets are generated and published over the network, for someone who receives them.
- Obstacles are sent over `topic1`, targets over `topic2`. Network configurations (domain, topics, IPs) are set in `config.json`.

## Configuration (config.json)
The `config.json` file includes parameters such as:
```json
{
    "drone_mass": 1.0,
    "viscous_coefficient": 1.0,
    "obstacle_repulsion_gain": 0.5,
    "obstacle_influence_radius": 5.0,
    "network": {
        "domain_num":0,
        "obstacles_topic": "topic1",
        "targets_topic": "topic2",
        "ip_address": "127.0.0.1"
    }
}
```
## How to Run
1. Compile the project:
   ```bash
   ./compile.sh
   ```
2. Run the simulation:
   ```bash
   ./master
   ```
3. Follow on-screen instructions to select the mode.

## Dependencies
- `ncurses` for terminal visualization
- `FastDDS` for remote communication
- `cjson`   for reading configurations

## Memory Leak Check
Run Valgrind to verify memory safety:
```bash
valgrind --leak-check=full ./master
VALGRIND MEMORY LEAK CHECK
==5927== HEAP SUMMARY:
==5927== All heap blocks were freed -- no leaks are possible
==5927== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

## Log of Simulation
```
[2025-02-08 01:12:28] Dynamics started. PID: 13314
[2025-02-08 01:12:28] Blackboard server started. PID: 13312
[2025-02-08 01:12:28] Big brother Watchdog process is watching. PID: 13316
[2025-02-08 01:12:28] Obstacle process started. PID: 13317
[2025-02-08 01:12:28] Target process started. PID: 13318
[2025-02-08 01:12:29] Keyboard process started. PID: 13363
[2025-02-08 01:12:29] Window process started. PID: 13365
[2025-02-08 01:13:35] Drone got a target at position (9, 6)
[2025-02-08 01:14:01] Drone got a target at position (15, 3)
```

## Credits
Developed as part of the Advanced and Robot Programming assignments. 
Dan Gookins' Guide to Ncurses Programming is a must read.

---
*Note: Ensure FastDDS is installed and configured properly for remote modes.*

